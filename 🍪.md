<html>
<head>
 <title>Shortest Path Visualization</title>
 <style>
 canvas {
 border: 1px solid #000000;
 }
 </style>
</head>
<body>
 <h1>Shortest Path Visualization</h1>
 <canvas id="canvas" width="500" height="500"></canvas>

 <script>
 // This code implements Dijkstra's algorithm to find the shortest path between two HTML elements and draws it on a canvas

 // Vertex class to represent each HTML element
 class Vertex {
 constructor(id, x, y) {
 this.id = id;
 this.x = x;
 this.y = y;
 this.adjacent = []; // array to hold adjacent vertices
 }

 addAdjacent(vertex) {
 this.adjacent.push(vertex); // add adjacent vertex to the array
 }
 }

 // Graph class to hold all the vertices
 class Graph {
 constructor() {
 this.vertices = []; // array to hold all vertices
 this.map = {}; // hash map to store vertices by their ids
 }

 addVertex(vertex) {
 this.vertices.push(vertex); // add vertex to the array
 this.map[vertex.id] = vertex; // add vertex to the map
 }
 }

 // Function to calculate the Euclidean distance between two vertices
 function getDistance(v1, v2) {
 const dx = v1.x - v2.x;
 const dy = v1.y - v2.y;
 return Math.sqrt(dx * dx + dy * dy);
 }

 // Dijkstra's algorithm implementation
 function dijkstra(graph, startId, endId) {
 const distances = {}; // object to hold distances from start vertex to each vertex
 const previous = {}; // object to hold previous vertex in the shortest path
 const unvisited = new Set(); // set to hold unvisited vertices

 graph.vertices.forEach((vertex) => {
 distances[vertex.id] = Infinity; // set initial distance to infinity
 previous[vertex.id] = null; // set initial previous vertex to null
 unvisited.add(vertex.id); // add vertex to the set of unvisited vertices
 });

 distances[startId] = 0; // set distance to start vertex to 0

 while (unvisited.size > 0) {
 let minId = null;

 unvisited.forEach((vertexId) => {
 if (minId === null || distances[vertexId] < distances[minId]) {
 minId = vertexId; // find the vertex with the smallest distance
 }
 });

 if (minId === endId) {
 break; // if the end vertex is reached, break out of the loop
 }

 unvisited.delete(minId); // remove the vertex from the set of unvisited vertices

 const current = graph.map[minId]; // use the map to access the vertex in constant time

 current.adjacent.forEach((neighbor) => {
 const alt = distances[minId] + getDistance(current, neighbor); // calculate the distance to the neighbor vertex

 if (alt < distances[neighbor.id]) {
 distances[neighbor.id] = alt; // update the distance to the neighbor vertex
 previous[neighbor.id] = current.id; // update the previous vertex in the shortest path
 }
 });
 }

 const path = []; // array to hold the shortest path
 let currentId = endId;

 while (currentId !== null) {
 path.unshift(currentId); // add the current vertex to the beginning of the path array
 currentId = previous[currentId]; // set the current vertex to the previous vertex in the shortest path
 }

 return path; // return the shortest path
 }

 // Function to draw the shortest path on the canvas
 function drawShortestPath(graph, path) {
 const canvas = document.getElementById("canvas");
 const ctx = canvas.getContext("2d");

 ctx.clearRect(0, 0, canvas.width, canvas.height); // clear the canvas

 graph.vertices.forEach((vertex) => {
 ctx.beginPath();
 ctx.arc(vertex.x, vertex.y, 10, 0, 2 * Math.PI); // draw a circle at the vertex position
 ctx.fillStyle = "#FFFFFF"; // set the fill color to white
 ctx.fill();
 ctx.closePath();

 vertex.adjacent.forEach((neighbor) => {
 ctx.beginPath();
 ctx.moveTo(vertex.x, vertex.y); // move to the vertex position
 ctx.lineTo(neighbor.x, neighbor.y); // draw a line to the neighbor position
 ctx.strokeStyle = "#FFFFFF"; // set the stroke color to white
 ctx.lineWidth = 2; // set the line width to 2
 ctx.stroke();
 ctx.closePath();
 });
 });

 ctx.beginPath();
 ctx.strokeStyle = "#FF0000"; // set the stroke color to red
 ctx.lineWidth = 3; // set the line width to 3

 for (let i = 0; i < path.length - 1; i++) {
 const current = graph.map[path[i]]; // use the map to access the vertex in constant time
 const next = graph.map[path[i + 1]];
 ctx.moveTo(current.x, current.y); // move to the current vertex position
 ctx.lineTo(next.x, next.y); // draw a line to the next vertex position
 }

 ctx.stroke();
 ctx.closePath();
 }



 // Example usage
 const graph = new Graph();

 // Define HTML elements and their positions
 const elementA = new Vertex("A", 69, 69);
 const elementB = new Vertex("B", 11, 22);
 const elementC = new Vertex("C", 420, 420);
 const elementD = new Vertex("D", 34, 22);
 const elementE = new Vertex("E", 90, 56);

 // Define adjacency relationships
 elementA.addAdjacent(elementB);
 elementA.addAdjacent(elementD);
 elementB.addAdjacent(elementC);
 elementC.addAdjacent(elementD);
 elementC.addAdjacent(elementE);
 elementD.addAdjacent(elementE);

 // Add vertices to the graph
 graph.addVertex(elementA);
 graph.addVertex(elementB);
 graph.addVertex(elementC);
 graph.addVertex(elementD);
 graph.addVertex(elementE);

 // Find the shortest path from elementA to elementE
 const shortestPath = dijkstra(graph, "A", "E");

 // Draw the shortest path on the canvas
 drawShortestPath(graph, shortestPath);

 </script>
</body>
</html>
